"use strict";(globalThis.webpackChunksmsApp=globalThis.webpackChunksmsApp||[]).push([[495],{9876:(e,n,t)=>{t.r(n),t.d(n,{default:()=>l,immutable:()=>o});var r=t(380),i=t(8139),s=t(5434);const a=r.use||(e=>{if("pending"===e.status)throw e;if("fulfilled"===e.status)return e.value;throw"rejected"===e.status?e.reason:(e.status="pending",e.then((n=>{e.status="fulfilled",e.value=n}),(n=>{e.status="rejected",e.reason=n})),e)}),d={dedupe:!0};s.OBJECT.defineProperty(s.SWRConfig,"defaultValue",{value:s.defaultConfig});const u=(0,s.withArgs)(((e,n,t)=>{const{cache:u,compare:o,suspense:l,fallbackData:c,revalidateOnMount:f,revalidateIfStale:E,refreshInterval:g,refreshWhenHidden:R,refreshWhenOffline:h,keepPreviousData:v}=t,[U,p,T,V]=s.SWRGlobalState.get(u),[b,m]=(0,s.serialize)(e),C=(0,r.useRef)(!1),S=(0,r.useRef)(!1),L=(0,r.useRef)(b),O=(0,r.useRef)(n),I=(0,r.useRef)(t),_=()=>I.current,k=()=>_().isVisible()&&_().isOnline(),[w,A,D,y]=(0,s.createCacheHelper)(u,b),N=(0,r.useRef)({}).current,F=(0,s.isUndefined)(c)?t.fallback[b]:c,P=(e,n)=>{for(const t in N){const r=t;if("data"===r){if(!o(e[r],n[r])){if(!(0,s.isUndefined)(e[r]))return!1;if(!o(z,n[r]))return!1}}else if(n[r]!==e[r])return!1}return!0},M=(0,r.useMemo)((()=>{const e=!!b&&!!n&&((0,s.isUndefined)(f)?!_().isPaused()&&!l&&(!!(0,s.isUndefined)(E)||E):f),t=n=>{const t=(0,s.mergeObjects)(n);return delete t._k,e?{isValidating:!0,isLoading:!0,...t}:t},r=w(),i=y(),a=t(r),d=r===i?a:t(i);let u=a;return[()=>{const e=t(w());return P(e,u)?(u.data=e.data,u.isLoading=e.isLoading,u.isValidating=e.isValidating,u.error=e.error,u):(u=e,e)},()=>d]}),[u,b]),W=(0,i.useSyncExternalStore)((0,r.useCallback)((e=>D(b,((n,t)=>{P(t,n)||e()}))),[u,b]),M[0],M[1]),j=!C.current,G=U[b]&&U[b].length>0,H=W.data,Y=(0,s.isUndefined)(H)?F:H,q=W.error,x=(0,r.useRef)(Y),z=v?(0,s.isUndefined)(H)?x.current:H:Y,B=!(G&&!(0,s.isUndefined)(q))&&(j&&!(0,s.isUndefined)(f)?f:!_().isPaused()&&(l?!(0,s.isUndefined)(Y)&&E:(0,s.isUndefined)(Y)||E)),J=!!(b&&n&&j&&B),K=(0,s.isUndefined)(W.isValidating)?J:W.isValidating,Q=(0,s.isUndefined)(W.isLoading)?J:W.isLoading,X=(0,r.useCallback)((async e=>{const n=O.current;if(!b||!n||S.current||_().isPaused())return!1;let r,i,a=!0;const d=e||{},u=!T[b]||!d.dedupe,l=()=>s.IS_REACT_LEGACY?!S.current&&b===L.current&&C.current:b===L.current,c={isValidating:!1,isLoading:!1},f=()=>{A(c)},E=()=>{const e=T[b];e&&e[1]===i&&delete T[b]},g={isValidating:!0};(0,s.isUndefined)(w().data)&&(g.isLoading=!0);try{if(u&&(A(g),t.loadingTimeout&&(0,s.isUndefined)(w().data)&&setTimeout((()=>{a&&l()&&_().onLoadingSlow(b,t)}),t.loadingTimeout),T[b]=[n(m),(0,s.getTimestamp)()]),[r,i]=T[b],r=await r,u&&setTimeout(E,t.dedupingInterval),!T[b]||T[b][1]!==i)return u&&l()&&_().onDiscarded(b),!1;c.error=s.UNDEFINED;const e=p[b];if(!(0,s.isUndefined)(e)&&(i<=e[0]||i<=e[1]||0===e[1]))return f(),u&&l()&&_().onDiscarded(b),!1;const d=w().data;c.data=o(d,r)?d:r,u&&l()&&_().onSuccess(r,b,t)}catch(e){E();const n=_(),{shouldRetryOnError:t}=n;n.isPaused()||(c.error=e,u&&l()&&(n.onError(e,b,n),(!0===t||(0,s.isFunction)(t)&&t(e))&&(_().revalidateOnFocus&&_().revalidateOnReconnect&&!k()||n.onErrorRetry(e,b,n,(e=>{const n=U[b];n&&n[0]&&n[0](s.revalidateEvents.ERROR_REVALIDATE_EVENT,e)}),{retryCount:(d.retryCount||0)+1,dedupe:!0}))))}return a=!1,f(),!0}),[b,u]),Z=(0,r.useCallback)(((...e)=>(0,s.internalMutate)(u,L.current,...e)),[]);if((0,s.useIsomorphicLayoutEffect)((()=>{O.current=n,I.current=t,(0,s.isUndefined)(H)||(x.current=H)})),(0,s.useIsomorphicLayoutEffect)((()=>{if(!b)return;const e=X.bind(s.UNDEFINED,d);let n=0;const t=(0,s.subscribeCallback)(b,U,((t,r={})=>{if(t==s.revalidateEvents.FOCUS_EVENT){const t=Date.now();_().revalidateOnFocus&&t>n&&k()&&(n=t+_().focusThrottleInterval,e())}else if(t==s.revalidateEvents.RECONNECT_EVENT)_().revalidateOnReconnect&&k()&&e();else{if(t==s.revalidateEvents.MUTATE_EVENT)return X();if(t==s.revalidateEvents.ERROR_REVALIDATE_EVENT)return X(r)}}));return S.current=!1,L.current=b,C.current=!0,A({_k:m}),B&&((0,s.isUndefined)(Y)||s.IS_SERVER?e():(0,s.rAF)(e)),()=>{S.current=!0,t()}}),[b]),(0,s.useIsomorphicLayoutEffect)((()=>{let e;function n(){const n=(0,s.isFunction)(g)?g(w().data):g;n&&-1!==e&&(e=setTimeout(t,n))}function t(){w().error||!R&&!_().isVisible()||!h&&!_().isOnline()?n():X(d).then(n)}return n(),()=>{e&&(clearTimeout(e),e=-1)}}),[g,R,h,b]),(0,r.useDebugValue)(z),l&&(0,s.isUndefined)(Y)&&b){if(!s.IS_REACT_LEGACY&&s.IS_SERVER)throw new Error("Fallback data is required when using suspense in SSR.");O.current=n,I.current=t,S.current=!1;const e=V[b];if(!(0,s.isUndefined)(e)){const n=Z(e);a(n)}if(!(0,s.isUndefined)(q))throw q;{const e=X(d);(0,s.isUndefined)(z)||(e.status="fulfilled",e.value=!0),a(e)}}return{mutate:Z,get data(){return N.data=!0,z},get error(){return N.error=!0,q},get isValidating(){return N.isValidating=!0,K},get isLoading(){return N.isLoading=!0,Q}}})),o=e=>(n,t,r)=>(r.revalidateOnFocus=!1,r.revalidateIfStale=!1,r.revalidateOnReconnect=!1,e(n,t,r)),l=(0,s.withMiddleware)(u,o)}}]);